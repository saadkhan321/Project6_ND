# CS6300 SDP Fall 2017 - Group Project
by Isaac Silva (```isilva6@gatech.edu```), Mukul Pai (```mpai8@gatech.edu```) & Saad Khan (```skhan315@gatech.edu```)

## Word Scramble Game

## *Individual Designs*

### Design 1

![Isaac Silva's Design](designs/design_Isaac_Silva.png)

The UML design shown above was created by Isaac Silva. One of the main highlights for this design is that it is very clean and very well organized. The design has excellent portrayal of the overall system to be implemented which made it very easy to visualize the overall design of the system. The design avoids extra cluttering by including most of the design requirements within four modules and also incorporates all the functional requirements needed by the system. Class components described in the UML are consistent i.e all components accurately display class specific attributes and functions. Design also uses a combination of getter and setter methods encompassing good programming practice. Interaction between the components are showcased explicitly by providing concise explanation of each connection.

As an entry point to the application, the designer uses a 'User' class by including most of the essential design requirements such as creating a new player, viewing player statistics, maintaining game progress, solved game list, etc. Similarly, the 'Game' class, quite aptly, handles everything pertaining to the word scramble game as well as the statistics. The external web service utility also appropriately addresses the design requirements.

While the design covers everything that is required, it does not include any underlying database, which according to the designer, seems to be unnecessary for the model. Although, the design in less cluttered with minimal modules, however, to make the design easier to implement a few additional modules addressing specific tasks such as dedicated module to statistics, creating a new player, etc would have been more appropriate from implementation point of view. Never the less, the design makes a lot of sense overall and is used as the basis for the final team design. 


### Design 2

![Mukul Pai's Design](designs/design_Mukul_Pai.png)

The design presented above was created by Mukul Pai. Including a 'Statistics' class to encapsulate the logic of how to get statistics is one the main postives of this design. This design also expresses cardinality quite appropriately between the 'User' and the 'Player' and then between the 'Player' and the 'Scramble' classes. Another highlight of the design is that object oriented approach is clearly defined between the 'Scramble' class and associated classes 'NewScramble', 'ProgressScramble', etc & then between the 'Statistics' class and 'PlayerStatistics' and 'ScrambleStatistics' classes.

Similar to the rest of the team members, the design uses a 'User' class as an entry point to the application handling all the information that is required to create a new player. Along with that, the Scramble class and its associated classes clearly separated, addressing all what was required as part of the design requirements, however, the return data types for few of the methods were not that explicit, specifically the statistics object returned by few methods do not mentioned the returned data types.

The design having more detailed UML design can be very apt in some cases, however, a more simpler design could have been more appropriate as some of the additional classes could have been engulfed into the parent classes such as the 'Loggedin' feature and scramble (in-progress, completed). Another feaure not present in the diagram was an underlying database to handle player, scramble and statistical information.


### Design 3 

![Saad Khan's Design](designs/design_Saad_Khan.png)

This design was generated by Saad Khan. From the user point of view, this application design excellently covers all the different components that are to be involved in the application with accurate interactions and flow. Good design principles were followed to showcase attributes of each component along with their functionalities. This design also had similarities with another team member's design in terms of the appraoch taken to include statistics class (playerStatistics, scrambleStatistics) and also having multiple instances of the word scramble.

In comparison to rest of the individual member design, the application design begins a user class, where the user has a choice of either choosing to login if his/her user profile is already in the system otherwise just choose to enter as new player in order to land onto a new player profile creation page/activity. This way the design for the UI point of view seems less cluttered, however, a more simpler approch could have been to encompass it as an instance of the player class rather keeping it as a separate class. 

The design also includes an underlying database (providing connectivity between the external web service (EWS) and rest of the modules), which during team discussion was considered a feature that could have been excluded from the UML and this way the EWS, a centralized utility, could have been connected in a way to be accessed by all other components in the system. Overall nice job but there seem to be quite a few class and the design coudl have been simplified in certain cases such as 'createWordScramble' class could have been an instance of the 'wordScramble' class while 'solveWordScramble' class could aslo have been described a method for the 'wordScramble' class.



## *Team Design*

![Team Design](designs/design_team.png)

As a collective team effort, we setup multiple calls to visit various requirements of the design and reviewed pros and cons for each individual member's design. The disscussions were thorough which led to the final UML deisgn as shown above, which is an enhanced/updated version of the individual UML created by one of the team member, Isaac Silva. The team was in unanimous agreement that the application's entry point should be the 'User' class also evident in all the individual UML designs as well as the final design. It was decided that the 'User' class will give the option to the user to either create a new user profile by accepting user credentials such as first name, last name, email, user_id, etc or login if the profile is already in the system. This approach led to an agreement amongst team members on how to distinguish between new and existing players. 

It was agreed upon amongst the members that once the user is logged in as an existing player, he/she will have four options  to choose from. (1) to create a word scramble, realized by the addition of 'Game' class which will serve as a blueprint for word scramble creations. (2) to choose and solve word scrambles, this is realized by 'PlayEvent' association class providing actual game instance for a user. There was a lot of discussion on how to realize the viewing statistics (both player and scramble) part, once the player has logged in. As a result of team discussions, other 2 members, Mukul and Saad had explicitly used separate scramble and player statistic classes in their individual designs which was not the case in Isaac's design, so it was collectively agreed upon that (3) in the case where a player is able to view statistics on their created and solved word scrambles, should be addressed by addition of an associated class 'ScrambleStatistic' with each 'Game' instance. For the case (4) where a player may view his/her own statistics, a similar associated class 'PlayerStatistic' class was associated with each 'Player' instance.  



- PlayerStatistic

The above utility classes are responsible for retrieving all the statistics around Scrambles and Players


2 - Added a Statistic class associated with each Player instance: PlayerStatistic

This is evident in the final team design above (shown by the association between the 'Game' and the 'ScrambleStatistic' class) and is an enhancement to Isaac's individual design. 


As a result of team discussions, other 2 members, Mukul and Saad had explicitly used separate scramble and player statistic classes in their individual designs and thisthese updates were added onto Isaac's design 

Added a Statistic class associated with each Game instance: ScrambleStatistic

In the scenario that a user logged in with administrator rights we all agreed to the functionality an admin will have in the system which were to: 1)Add a player 2) Add a cryptogram 3) Edit a cryptogram. This would be built out within the administrator class and in order for these operations to occur there had to be a relationship between Administrator and Player, and between Administrator and Cryptogram. The relationship between the Administrator and the Player was simple enough to just add a new player entry. However, between the Administrator and the Cryptogram was more involved and an area of discussion amongst the team. We could either make a straight call to cryptogram for both the edit and the add however, if we used this approach where would the result message and the generated unique ID reside. It could have been on either the Cryptogram class or the helper class of addCryptogram. We agreed to use the helper addCryptogram class for the addCryptogram method for the admin. What is not shown here as we did not believe it had a large impact on the design was the cryptogram validation. This we decided would occur within the administrator method addCryptogram. Though not all individual designs included the same functionality, the team design incorporated a simple “edits” association and included a separate editCryptogram operation within Administrator to signify that the administrator should be able to edit any cryptogram at any time, not just at the time they submit a new one. The association between Player and Cryptogram was commonly agreed to be “solves” with the choosing and viewing of cryptograms implied by that simple relationship.

In the scenario that a user logged in as a player to the system they will be brought to the Player class in which we all agreed should contain the values of the users first name and last name. There was some discussion on whether these values should reside on the user level but we did not believe that the administrator needed to have these values. As a player in the system, the user shall be able to: 1)View a list of Cryptograms 2) Choose a cryptogram to solve 3) Solve the cryptogram 4) View a list of player ratings. In order to handle these scenarios we have 4 methods which will do these exact requirements. viewCryptogram is a method which will request the uniqueID of the cryptogram that the user would like to solve. chooseCryptogram will display a list to the user in which the user can choose any of the cryptograms to view. solveCryptogram is where the player will begin to play the game and we will begin subroutines in order to keep track of metrics such as if the cryptogram was solved or not. This will tie into the utility class of PlayerRating that will store for each player the attributes which will be passed back to the method in the player class named listPlayerRatings. The player class will be tied to the database service in order to update this information once a player begins work on a cryptogram

The Cryptogram class will be used to store information on the cryptogram such as the encoded and decoded phrase for a cryptogram. Some team members included additional attributes such as a list of users who had correctly solved a particular cryptogram, but it was determined that such a list could be derived from the Player class and the relationship between Player and Cryptogram. There was also agreement that the Administrator class should not need any attributes but should include addPlayer and addCryptogram operations, in addition to the editCryptogram operation discussed earlier.

Once a cryptogram is added or edited, the cryptogram will communicate to the database so that any further requests to the cryptogram will be updated accordingly. Regarding the local database, all but one user’s individual diagram included a class entity to represent this component in the design. Two of the three users who included it left it as a complete “black box” while one user tried to add some details about the data structures that would be stored there. It was decided that there does not need to be a lot of detail about the database in this UML class diagram, so it was left as a simple class with no attributes or operations. A “uses” dependency was established between the DatabaseService and the User superclass as well as Cryptogram. Similarly, three team members included some kind of class structure to handle player ratings. It was decided we should have a class representing the collection of attributes belonging to a player such as totalSolved, totalStarted, and so on.

We discussed the ExternalWebService utility class and how exactly it will communicate with our system. We deemed that it should essentially be a gateway to an external server. As a result, this class will simply pass information about by using the methods sendPlayerRatings, sendCryptogram, requestPlayerRatings, and requestCryptogram.

1 - When starting the application, a user may choose to either create a new player or log in.  For simplicity, authentication is optional.  A (unique) username will be sufficient for logging in.

To realize this requirement, I added a class "User" to represent the player, with an attribute "username". A method signature was added to the same class:

- login(username: String): Boolean

That method returns true or false depending if the user logged in or not.


2 - After logging in, the application shall allow players to  (1) create a word scramble, (2) choose and solve word scrambles, (3) see statistics on their created and solved word scrambles, and (4) view the player statistics.

Even though this is more an UI requirement, it helped me understand some of the other elements of the domain. Thus, I added a class "Game" to be used as a blueprint for the creation of word scrambles and an association class "PlayEvent" for the actual action of a user playing a particular game instance. 


3 - The application shall maintain an underlying database to save persistent information across runs (e.g., word scrambles, player information, statistics).

I did not consider this requirement because the database does not affect the design directly.

4 - Word scrambles and statistics will be shared with other instances of the application.  An external web service utility will be used by the application to communicate with a central server to:

a - Add a player and ensure that their username is unique.
b - Send new word scrambles and receive a unique identifier for them.
c - Retrieve the list of scrambles, together with information on which player created each of them. 
d - Report a solved scramble.
e - Retrieve the list of players and the scrambles each have solved.


In order to realize this requirement, added an Utility class called "ExternalWebService" with the following methods in order to fulfill each of the above-described functionalities:

a - addUser(username: String): String 
b - addNewWordScrambleGame(game: Game): Integer
c - getListOfWordScrambleGamesAndAuthors(): ArrayList<Map<Game, User>>
d - reportSolvedScramble(game: Game)
e - retrievePlayersAndSolvedScrambles: ArrayList<Map<User, ArrayList< Game>>>
 

A few remarks on the steps to fulfill this requirement:

- Added unique identifier as a property in the Game class, according to indications of the "b" requirement.
- The addUser method returns an unique username as a String


5 - When creating a new player, a user will:

a - Enter the player’s first name.
b - Enter the player’s last name.
c - Enter the player’s desired username.
d - Enter the player’s email.  
e - Save the information.
f - Receive the returned username, with possibly a number appended to it to ensure that it is unique.

In order to realize this requirement, I added the following properties to the User class:

firstName: String
lastName: String
desiredUsername: String
username: String
email: String

The following methods were added:

- createNewPlayer(firstName, lastName, desiredUsername, email): String

The above method returns a username that the system registered by using the ExternalWebService utility class. The addUser method signature was changed to address that requirement and became as follows:

- addUser(firstName, lastName, desiredUsername, email): String

That method returns a player's username that the remote system assigned to the user. 


6 - To add a word scramble, the player will:

a - Enter a phrase (not scrambled).
b - Enter a clue. 
c - View the phrase scrambled by the system. If the player does not like the result, they may choose for the system to re-scramble it until they are satisfied.
d - Accept the results or return to previous steps.
e - View the returned unique identifier for the word scramble. The scramble may not be further edited after this point.


In order to realize this requirement, the following property fields were added to the Game class:

identifier: Integer
originalPhrase: String
clue: String
scrambledPhrase: String

The following methods were added to the Game class:

- createNewGame(phrase: String, clue: String): Integer
- refreshScrambledPhrase()
- saveGame(): Integer

A few remarks on the steps to fulfill this requirement:

- The createNewGame method saves the game object locally until the user accepts the scrambled phrase
- The refreshCrumbledPhrase method fulfills requirement "C" above
- The saveGame method saves the game and returns the final identifier
- The saveGame method uses the ExternalWebService utility class. More specifically the "addNewWordScrambleGame(game: Game): Integer" method signature


7 - A scramble shall only mix up alphabetic characters, keeping each word together. Words are contiguous sequences of alphabetic characters separated by one or more non-alphabetic characters.

In order to realize this requirement, the scrumbledPhrase property on the Game class was confirmed to be "String"

8 - All other characters and spacing will remain as they originally are.

This requirement does not affect the UML design

9 - When solving word scrambles, a player will:

a - View the list of unsolved word scrambles, by identifier, with any in progress scrambles marked and shown first.
b - Choose one word scramble to work on.
c - View the scramble.
d - Enter the letters in a different order to try to solve the scramble.
e - Submit a solution.
f - View whether it was correct.
g - Return either to the puzzle, if wrong, or to the list, if correct.


In order to realize this requirement, the following steps were taken:

- In order to fulfill requirement "a", the method "retrievePlayersAndSolvedScrambles: ArrayList<Map<User, ArrayList< Game>>>" available in the ExternalWebService utility class is used to filter the results of the "getListOfWordScrambleGamesAndAuthors(): ArrayList<Map<Game, User>>" method, also available the same utility class. This gives a list of unsolved word scrambles for a particular user. To show the scrambles in progress for a user, a method called "getInProgressGameList(): List<Game>" was added to the User class. The list returned by this method is used in combination with the list returned and filtered by the mentioned utility methods.
- A method signature "submitSolution(solution: String): Boolean" was added. If the solution is correct the method returns true, otherwise it returns false.
- If the solution is correct call the method "reportSolvedScramble(game: Game)", available in the ExternalWebService utility class.


10 - A player may exit any scramble in progress at any time and return to it later.  The last state of the puzzle will be preserved.

In order to fulfill this requirement a property called "gameState" was added to the PlayEvent class. In addition, the following method signature was added to the same class:

- updateGameState(state: String)

This method assumes the game state is in a string format.


11 - The scramble statistics shall list all scrambles with (1) their unique identifier, (2) information on whether they were solved or created by the player, and (3) the number of times any player has solved them. This list shall be sorted by decreasing number of solutions.

In order to realize this requirement, two methods are used from the ExternalWebService utility class:

- retrievePlayersAndSolvedScrambles: ArrayList<Map<User, ArrayList< Game>>>
- getListOfWordScrambleGamesAndAuthors(): ArrayList<Map<Game, User>>

The former returns a list of all players and the scrambles each solved. The latter returns the list of all scrambles and its authors. By callind both methods, filtering the results and making the appropriate calculations, we get fulfill the requirements described in this section. For convenience, we also added a new property called "numberOfTimesSolved: Integer" in the Game class, in order to facilitate sorting of games by the number of times players solved them. A setter method called "setSolvedTimes(game: Game)" was added to the same class in order to set the numberOfTimesSolved attribute.


A method called "getScrambleStatistics()" was added to the Game clas in order to wrap the calls to the methods in the ExternalWebService utility class and perform the necessary filtering and calculations. 


12 - The player statistics will list players’ first names and last names, with (1) the number of scrambles that the player has solved, (2) the number of new scrambles created, and (3) the average number of times that the scrambles they created have been solved by other players.  It will be sorted by decreasing number of scrambles that the player has solved.

In order to realize this requirement, two methods are used from the ExternalWebService utility class:

- retrievePlayersAndSolvedScrambles: ArrayList<Map<User, ArrayList< Game>>>
- getListOfWordScrambleGamesAndAuthors(): ArrayList<Map<Game, User>>

By callind the above methods, filtering the results and performing the necessary calculations accordingly, points 1,2,3 can be easily met. In order to facilitate sorting and making the calculations more explicit, the following properties, alongside with its setters methods, were added to the User class:

- numberOfSolvedGames: Integer
- numberOfGamesCreated: Integer 
- authoredGamesSolvedAverage: Integer


A method called "getPlayerStatistics()" was added to the User class in order to wrap the calls to the methods in the ExternalWebService utility class and perform the necessary filtering and calculations. 


13 - The User Interface (UI) shall be intuitive and responsive.

This requirement does not affect the UML design
 


Update Notes:

Created a design that better encapsulated the functionality required by the ScrambleStatistics and PlayerStatistic components. The changes in that regards were the following:

1 - Added two utility classes:


- ScrambleStatistic
- PlayerStatistic

The above utility classes are responsible for retrieving all the statistics around Scrambles and Players


2 - Added a Statistic class associated with each Player instance: PlayerStatistic
3 - Added a Statistic class associated with each Game instance: ScrambleStatistic

This design encapsulates different types depending on its concern. Proper encapsulation is key for loose-coupling and flexibility. 

In addition, proper naming of properties and methods is paramount for the successful communication of requirements across all team members. 

In the process of coming up with this design, it was crucial to combine the best intuitions present in each of the team's designs. Coming up with a class structure that is clean, concise and properly scope is key for properly capturing and executing requirements. 

## *Summary*

Main objective of coming together as a team for the final design was to get individual as well as collective team feedback which turned out to be quite useful. At the beginning, a review word document was shared amongst the team members in between successive team meetings. This way, each team member was able to perform first draft of the review based on other team member's design. This left each team member and the team collectively in a better position to address the do's and don’ts for the final design and by the time the team got together to discuss the final design each member had a clear idea of what was to go into the final design.

The whole experience of team work highlighted both theoretical and industrial practices of software development process. This approach and the feedback from within the team also helped each team member to review the capabilities of their own individual design. Building the final design was an iterative process with the team observing and mitigating possible design shortcomings along the way.

The team also took a fresh approach by re-visiting the requirements for assignment 5. Although, the final design was a version of one of the team member's design, re-visiting the requirements helped the team address the task at hand in a much better way. Finally, when compiling the team design, members put extra effort to make it precisely while clearly portraying what was required of it without making it too intricate.
